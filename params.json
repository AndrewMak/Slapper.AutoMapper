{"google":"UA-36766254-1","body":"Slapper.AutoMapper\r\n=================\r\n*Slap your ORM into submission.*\r\n\r\nSlapper.AutoMapper maps dynamic data to static types.\r\n\r\nProject Homepage: http://randyburden.com/Slapper.AutoMapper/\r\n\r\n###What is it?###\r\n\r\nSlapper.AutoMapper is a single file mapping library that can convert dynamic data into static types and populate complex nested\r\nchild objects.\r\n\r\nAnother way of stating it is that it allows you to convert an `IDictionary<string, object>` to a strongly typed object. \r\n\r\nWhy use an IDictionary? Because a C# dynamic can easily be cast to one allowing this library to be used in a variety of ways.\r\n\r\nOkay, so what... doesn't other ORMs do this?\r\n\r\nAnswer: Yes and no but the philosophy of this project is much different. This small single file library is meant to be used as a \r\npiece/lego block in a larger solution and puts a great emphasis on its ability to map to complex nested properties such as mapping \r\na Customer and it's list of Orders and it's list of OrderDetails.\r\n\r\n###Is this an ORM?###\r\n\r\nNo, this is not an ORM in itself but can easily be extended to create one. This library can be thought of as a building \r\nblock of an ORM or used as an extension to an existing ORM or Micro-ORM.\r\n\r\nORMs typically query the database and then map the data into objects. Slapper just handles the mapping part and essentially\r\nonly has one input: a dictionary of property names and values.\r\n\r\n###What problems does this solve?###\r\n\r\nSimply put, it allows you to convert dynamic data into strongly typed objects with ease and populating complex nested child \r\nobjects in your object hierarchy comes free out of the box --something severely lacking in almost every Micro-ORM solution!\r\n\r\n###Auto mapping?###\r\n\r\nYep, Slapper.AutoMapper stays true to its name and allows auto-mapping between dynamic data and static types by using\r\nconventions to find a given classes identifier ( the property that gives the class uniqueness ). This allows Slapper to \r\nfigure out how to effectively group objects together so that you do not get duplicate results. You can even supply your \r\nown conventions or manually specify the identifiers by either calling a simple API method or decorating your types with \r\nan attribute.\r\n\r\nAnd yes, multiple identifiers aka Composite Primary Keys are supported out of the box!\r\n\r\n###Some more ramblings...###\r\n\r\nMicro-ORMs have been springing up left and right but many of them are quite basic in their functionality. Many have also \r\nbeen opting for either very basic mapping to strongly typed objects or skipping it completely and opting for a completely \r\ndynamic solution.\r\n\r\nDynamics are super cool and have their place but strongly typed objects have their place too and that is what this library \r\nfocuses on... converting dynamic data into strongly typed objects with strong support for populating nested child properties. \r\n\r\n###Target Audience###\r\n\r\nC# developers is a given but besides that, anyone looking to enhance an ORM or write their own would find that Slapper.AutoMapper\r\ncan take care of a lot of the hard work or mapping back to strongly typed objects.\r\n\r\nBecause Slapper.AutoMappers primary input is simply an Dictionary of property names and values, as long as you can get your data\r\ninto that form, your good to go. One thing to note though is that the values must be the same data types as the strongly typed object\r\nyou are wishing to create. Slapper.AutoMapper does not handle data type conversions, that is up to you the consumer to feed the proper\r\ndata into the library.\r\n\r\nAnd that's it, feel free to explore the examples below and the unit tests and hack away. This library is licensed with the MIT license\r\nso feel free to re-use the code in your own projects any way you please. I only ask that you keep the license comment at the top of the\r\nfile or any file that uses significant portions of this projects code for proper attribution.\r\n\r\nNow let the slapping commence! :)\r\n\r\n\r\nUsage - Mapping\r\n===============\r\n\r\n###Simple Example Using a Dictionary###\r\n\r\nThe following simple example maps a dictionary of property names and values to a Person class.\r\n\r\n```csharp\r\npublic class Person\r\n{\r\n\tpublic int Id;\r\n\tpublic string FirstName;\r\n\tpublic string LastName;\r\n}\r\n\t\t\r\n[Test]\r\npublic void Can_Map_Matching_Field_Names_With_Ease()\r\n{\r\n    // Arrange\r\n    var dictionary = new Dictionary<string, object>\r\n                            {\r\n                                { \"Id\", 1 },\r\n                                { \"FirstName\", \"Clark\" },\r\n                                { \"LastName\", \"Kent\" }\r\n                            };\r\n\r\n    // Act\r\n    var person = Slapper.AutoMapper.Map<Person>( dictionary );\r\n\r\n    // Assert\r\n    Assert.NotNull( person );\r\n    Assert.That( person.Id == 1 );\r\n    Assert.That( person.FirstName == \"Clark\" );\r\n    Assert.That( person.LastName == \"Kent\" );\r\n}\r\n```\r\n\r\n###Simple Example Using Dynamic###\r\n\r\nThe following simple example maps a dynamic object to a Person class.\r\n\r\nWhen mapping dynamics use the `MapDynamic<T>()` method instead of the `Map<T>()` method.\r\n\r\n```csharp\r\npublic class Person\r\n{\r\n\tpublic int Id;\r\n\tpublic string FirstName;\r\n\tpublic string LastName;\r\n}\r\n\t\t\r\n[Test]\r\npublic void Can_Map_Matching_Field_Names_Using_Dynamic()\r\n{\r\n    // Arrange\r\n    dynamic dynamicPerson = new ExpandoObject();\r\n    dynamicPerson.Id = 1;\r\n    dynamicPerson.FirstName = \"Clark\";\r\n    dynamicPerson.LastName = \"Kent\";\r\n\r\n    // Act\r\n    var person = Slapper.AutoMapper.MapDynamic<Person>( dynamicPerson ) as Person;\r\n            \r\n    // Assert\r\n    Assert.NotNull( person );\r\n    Assert.That( person.Id == 1 );\r\n    Assert.That( person.FirstName == \"Clark\" );\r\n    Assert.That( person.LastName == \"Kent\" );\r\n}\r\n```\r\n\r\n###Mapping Nested Types Using a Dictionary###\r\n\r\nThe following example maps a list of dictionaries of property names and values to a Customer class and using underscore notation (\"_\"), \r\nSlapper.AutoMapper properly populates the nested child types. You can just as easily use a list of dynamics too.\r\n\r\nAs an example, the following SQL would return similar results to what is in the dictionaries in the example below ( Note the use of SQL aliases ):\r\n```sql\r\nSELECT\tc.CustomerId,\r\n\t\tc.FirstName,\r\n\t\tc.LastName,\r\n\t\to.OrderId AS Orders_OrderId,\r\n\t\to.OrderTotal AS Orders_OrderTotal,\r\n\t\tod.OrderDetailId AS Orders_OrderDetails_OrderId,\r\n\t\tod.OrderDetailId AS Orders_OrderDetails_OrderDetailId,\r\n\t\tod.OrderDetailTotal AS Orders_OrderDetails_OrderDetailTotal\r\nFROM\tCustomer c\r\n\t\tJOIN Order o ON c.CustomerId = o.CustomerId\r\n\t\tJOIN OrderDetail od ON o.OrderId = od.OrderId\r\n```\r\n\r\nThis example is indicative of the results you would commonly encounter when querying a database and joining on an Orders\r\nand OrderDetails table --you would get back duplicate results in some fields. Notice how the CustomerId in both dictionaries\r\nare the same. Because of Slapper.AutoMapper's default conventions, it will identify the CustomerId field as being the \r\nidentifier ( or primary key so to speak ). This means that when it attempts to convert the second dictionary to a Customer \r\nobject, it will see that it has already created a Customer object with an CustomerId of 1 and will simply re-use the previous \r\ninstance resulting in only one Customer object being returned back. This is how Slapper.AutoMapper effectively groups results\r\ntogether and is the key to this libraries awesomeness.\r\n\r\n\r\n```csharp\r\npublic class Customer\r\n{\r\n\tpublic int CustomerId;\r\n\tpublic string FirstName;\r\n\tpublic string LastName;\r\n\tpublic IList<Order> Orders;\r\n}\r\n\r\npublic class Order\r\n{\r\n\tpublic int OrderId;\r\n\tpublic decimal OrderTotal;\r\n\tpublic IList<OrderDetail> OrderDetails;\r\n}\r\n\r\npublic class OrderDetail\r\n{\r\n\tpublic int OrderDetailId;\r\n\tpublic decimal OrderDetailTotal;\r\n}\r\n\t\t\r\n[Test]\r\npublic void I_Can_Map_Nested_Types_And_Resolve_Duplicate_Entries_Properly()\r\n{\r\n\t// Arrange\r\n\tvar dictionary = new Dictionary<string, object>\r\n\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t { \"CustomerId\", 1 },\r\n\t\t\t\t\t\t\t { \"FirstName\", \"Bob\" },\r\n\t\t\t\t\t\t\t { \"LastName\", \"Smith\" },\r\n\t\t\t\t\t\t\t { \"Orders_OrderId\", 1 },\r\n\t\t\t\t\t\t\t { \"Orders_OrderTotal\", 50.50m },\r\n\t\t\t\t\t\t\t { \"Orders_OrderDetails_OrderDetailId\", 1 },\r\n\t\t\t\t\t\t\t { \"Orders_OrderDetails_OrderDetailTotal\", 25.00m }\r\n\t\t\t\t\t\t };\r\n\r\n\tvar dictionary2 = new Dictionary<string, object>\r\n\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t { \"CustomerId\", 1 },\r\n\t\t\t\t\t\t\t { \"FirstName\", \"Bob\" },\r\n\t\t\t\t\t\t\t { \"LastName\", \"Smith\" },\r\n\t\t\t\t\t\t\t { \"Orders_OrderId\", 1 },\r\n\t\t\t\t\t\t\t { \"Orders_OrderTotal\", 50.50m },\r\n\t\t\t\t\t\t\t { \"Orders_OrderDetails_OrderDetailId\", 2 },\r\n\t\t\t\t\t\t\t { \"Orders_OrderDetails_OrderDetailTotal\", 25.50m }\r\n\t\t\t\t\t\t };\r\n\r\n\tvar list = new List<IDictionary<string, object>> { dictionary, dictionary2 };\r\n\r\n\t// Act\r\n\tvar customers = Slapper.AutoMapper.Map<Customer>( list );\r\n\r\n\t// Assert\r\n\t\r\n\t// There should only be a single customer\r\n\tAssert.That( customers.Count() == 1 );\r\n\r\n\t// There should only be a single Order\r\n\tAssert.That( customers.FirstOrDefault().Orders.Count == 1 );\r\n\r\n\t// There should be two OrderDetails\r\n\tAssert.That( customers.FirstOrDefault().Orders.FirstOrDefault().OrderDetails.Count == 2 );\r\n}\r\n```\r\n\r\nUsage - Auto Mapping and Identifiers\r\n====================================\r\n\r\n###Auto Mapping###\r\n\r\nAuto mapping allows Slapper to figure out how to effectively group objects together so that you do not get \r\nduplicate results. Now internally, no actual grouping is happening but this is the easiest way to conceptualize\r\nhow it works.\r\n\r\nFor the curious, the actual implementation relies upon an instance cache implemented as a Dictionary where the key is the all of\r\nthe identifier's hashes summed together and the value being the instance.\r\n\r\nSo a classes identifier(s) play an important role in the ability of the mapper to effectively group objects together. If no\r\nidentifiers are found, the mapper will still map the results to the requested type but there will be duplicates in the results.\r\n\r\n\r\n####Default Convention####\r\nSlapper.AutoMapper uses three different conventions in an attempt to locate/match a requested types\r\nidentifier:\r\n- Id\r\n- TypeName + Id\r\n- TypeName + Nbr\r\n\r\nFor example, if your Customer object has any of the following properties or fields, it will use it as the identifier:\r\n- Id\r\n- CustomerId\r\n- CustomerNbr\r\n\r\n####Creating Your Own Convention####\r\n\r\nYou can specify your own conventions very easily. The following example creates a convention of TypeName + _Id:\r\n\r\n```csharp\r\nSlapper.AutoMapper.Configuration.IdentifierConventions.Add( type => type.Name + \"_Id\" );\r\n````\r\n\r\n####Manually Specifying the Identifier(s)####\r\n\r\nSlapper allows you to manually specify a classes identifiers. 1 through N number of identifiers are supported.\r\n\r\nThe following example specifies two identifiers for the Customer object by using the AddIdentifiers() method:\r\n\r\n\r\n```csharp\r\npublic class Customer\r\n{\r\n\tpublic int CustomerId;\r\n\r\n\tpublic string CustomerType;\r\n\r\n\tpublic string FirstName;\r\n\r\n\tpublic string LastName;\r\n}\r\n\r\nSlapper.AutoMapper.Configuration.AddIdentifiers( typeof( Customer ), new List<string> { \"CustomerId\", \"CustomerType\" } );\r\n````\r\n\r\n####Attribute-based Identifiers####\r\n\r\nSlapper.AutoMapper also supports attribute-based identifiers.\r\n\r\nBy default, the library uses it's own Id attribute that allows you to simply decorate the identifiers on your class with\r\na `[Slapper.AutoMapper.Id]` attribute.\r\n\r\nIf you wish to use your own attribute instead of the default one, just set the Type to use on the following field:\r\n\r\n```csharp\r\nSlapper.AutoMapper.Configuration.IdentifierAttributeType = typeof( YourCustomAttribute );\r\n``` \r\n\r\nThe following example specifies two identifiers for the Customer object:\r\n\r\n```csharp\r\npublic class Customer\r\n{\r\n\t[Slapper.AutoMapper.Id]\r\n\tpublic int CustomerId;\r\n\r\n\t[Slapper.AutoMapper.Id]\r\n\tpublic string CustomerType;\r\n\r\n\tpublic string FirstName;\r\n\r\n\tpublic string LastName;\r\n}\r\n````\r\n\r\nUsage - Caching\r\n===============\r\n\r\n####Caching Explained####\r\n\r\nSlapper.AutoMapper internally maintains a cache of every object it creates, referred to as the instance cache.\r\nThis cache plays an important role in Slapper's ability to easily lookup existing objects and ultimately assists\r\nin the ability for Slapper.AutoMapper to populate complex nested types.\r\n\r\nSlapper.AutoMapper itself never removes an instance from this cache, so if you tell it to create 50,000 objects, \r\nthen there are going to be 50,000 objects in the cache for the lifetime of the current thread. \r\n\r\nThe instance cache exists for the lifetime of the current thread and each of your application's threads will\r\nget it's own unique cache making use of this library thread safe.\r\n\r\n####Clearing the Cache###\r\n\r\nSlapper never clears the cache because we feel that it should be the consumer of this library that should have that \r\nresponsibility.\r\n\r\nIf you would like to clear this cache, you can do so at any time like so:\r\n\r\n```csharp\r\nSlapper.AutoMapper.Cache.ClearInstanceCache();\r\n````\r\n\r\n\r\n###License###\r\nMIT","name":"Slapper.AutoMapper","tagline":"Slapper.AutoMapper maps dynamic data to static types. Slap your ORM into submission!","note":"Don't delete this file! It's used internally to help with page regeneration."}