{"name":"Slapper.AutoMapper","tagline":"Slapper.AutoMapper maps dynamic data to static types. Slap your ORM into submission!","body":"Slapper.AutoMapper\r\n=================\r\n*Slap your data into submission.*\r\n\r\nSlapper.AutoMapper maps dynamic data to static types.\r\n\r\n<a href=\"https://www.nuget.org/packages/Slapper.AutoMapper\"><img src=\"https://img.shields.io/nuget/v/Slapper.AutoMapper.svg\" alt=\"NuGet Version\" /></a> \r\n<a href=\"https://www.nuget.org/packages/Slapper.AutoMapper\"><img src=\"https://img.shields.io/nuget/dt/Slapper.AutoMapper.svg\" alt=\"NuGet Download Count\" /></a>\r\n\r\n###What is it?###\r\n\r\nSlapper.AutoMapper ( Pronounced Slapper-Dot-Automapper ) is a mapping library that can convert dynamic data into \r\nstatic types and populate complex nested child objects.\r\n\r\nIt primarily converts C# dynamics and `IDictionary<string, object>` to strongly typed objects and supports\r\npopulating an entire object graph by using underscore notation to underscore into nested objects.\r\n\r\nWhy use an IDictionary? Because a C# dynamic ( well really an ExpandoObject ) can easily be cast to one allowing \r\nthis library to be used in a variety of ways not only with dictionaries of property names and values but with dynamics as well.\r\n\r\nOkay, so what... doesn't other ORMs do this?\r\n\r\nAnswer: Yes and no but the philosophy of this project is much different. This small library is meant to be used as a \r\nbuilding block in a larger solution and puts a great emphasis on its ability to map to complex nested properties such as mapping \r\na Customer and it's list of Orders and it's list of OrderDetails.\r\n\r\n###Is this an ORM?###\r\n\r\nNo, this is not an ORM in itself but can easily be extended to create one. This library can be thought of as a building \r\nblock of an ORM or used as an extension to an existing ORM or Micro-ORM.\r\n\r\nORMs typically query the database and then map the data into objects. Slapper just handles the mapping part and essentially\r\nonly has one input: a dictionary of property names and values.\r\n\r\n###What problems does this solve?###\r\n\r\nSimply put, it allows you to convert dynamic data into strongly typed objects with ease and populating complex nested child \r\nobjects in your object hierarchy comes free out of the box --something severely lacking in almost every Micro-ORM solution!\r\n\r\n###Auto mapping?###\r\n\r\nYep, Slapper.AutoMapper stays true to its name and allows auto-mapping between dynamic data and static types by using\r\nconventions to find a given classes identifier ( the property that gives the class uniqueness ). This allows Slapper to \r\nfigure out how to effectively group objects together so that you do not get duplicate results. You can even supply your \r\nown conventions or manually specify the identifiers by either calling a simple API method or decorating your types with \r\nan attribute.\r\n\r\nAnd yes, multiple identifiers aka Composite Primary Keys are supported out of the box!\r\n\r\n###Some more ramblings...###\r\n\r\nMicro-ORMs have been springing up left and right but many of them are quite basic in their functionality. Many have also \r\nbeen opting for either very basic mapping to strongly typed objects or skipping it completely and opting for a completely \r\ndynamic solution.\r\n\r\nDynamics are super cool and have their place but strongly typed objects have their place too and that is what this library \r\nfocuses on... converting dynamic data into strongly typed objects with strong support for populating nested child properties. \r\n\r\n###Target Audience###\r\n\r\nThe target audience is C# developers looking to enhance an ORM or write their own. Slapper.AutoMapper\r\ncan take care of a lot of the hard work of mapping back to strongly typed objects.\r\n\r\nBecause Slapper.AutoMappers primary input is simply a dictionary of property names and values, as long as you can get your data\r\ninto that form, you're good to go. One thing to note is that the values must be the same data types as the strongly typed object's properties/fields\r\nyou are wishing to populate. Slapper.AutoMapper does not handle data type conversions, that is up to you the consumer to feed the proper\r\ndata into the library.\r\n\r\nAnd that's it, feel free to explore the examples below and the unit tests and hack away. This library is licensed with the MIT license\r\nso feel free to re-use the code in your own projects any way you please. I only ask that you keep the license comment at the top of the\r\nfile or any file that uses significant portions of this projects code for proper attribution.\r\n\r\nSlapper.AutoMapper is also available on NuGet as a compiled dll if you prefer that. Check it out at: http://www.nuget.org/packages/Slapper.AutoMapper/\r\n\r\nNow let the slapping commence! :)\r\n\r\n\r\nUsage - Mapping\r\n===============\r\n\r\n###Simple Example Using a Dictionary###\r\n\r\nThe following simple example maps a dictionary of property names and values to a Person class.\r\n\r\n```csharp\r\npublic class Person\r\n{\r\n\tpublic int Id;\r\n\tpublic string FirstName;\r\n\tpublic string LastName;\r\n}\r\n\t\t\r\n[Test]\r\npublic void Can_Map_Matching_Field_Names_With_Ease()\r\n{\r\n    // Arrange\r\n    var dictionary = new Dictionary<string, object>\r\n                            {\r\n                                { \"Id\", 1 },\r\n                                { \"FirstName\", \"Clark\" },\r\n                                { \"LastName\", \"Kent\" }\r\n                            };\r\n\r\n    // Act\r\n    var person = Slapper.AutoMapper.Map<Person>( dictionary );\r\n\r\n    // Assert\r\n    Assert.NotNull( person );\r\n    Assert.That( person.Id == 1 );\r\n    Assert.That( person.FirstName == \"Clark\" );\r\n    Assert.That( person.LastName == \"Kent\" );\r\n}\r\n```\r\n\r\n###Simple Example Using Dynamic###\r\n\r\nThe following simple example maps a dynamic object to a Person class.\r\n\r\nWhen mapping dynamics use the `MapDynamic<T>()` method instead of the `Map<T>()` method.\r\n\r\n```csharp\r\npublic class Person\r\n{\r\n\tpublic int Id;\r\n\tpublic string FirstName;\r\n\tpublic string LastName;\r\n}\r\n\t\t\r\n[Test]\r\npublic void Can_Map_Matching_Field_Names_Using_Dynamic()\r\n{\r\n    // Arrange\r\n    dynamic dynamicPerson = new ExpandoObject();\r\n    dynamicPerson.Id = 1;\r\n    dynamicPerson.FirstName = \"Clark\";\r\n    dynamicPerson.LastName = \"Kent\";\r\n\r\n    // Act\r\n    var person = Slapper.AutoMapper.MapDynamic<Person>( dynamicPerson ) as Person;\r\n            \r\n    // Assert\r\n    Assert.NotNull( person );\r\n    Assert.That( person.Id == 1 );\r\n    Assert.That( person.FirstName == \"Clark\" );\r\n    Assert.That( person.LastName == \"Kent\" );\r\n}\r\n```\r\n\r\n###Mapping Nested Types Using a Dictionary###\r\n\r\nThe following example maps a list of dictionaries of property names and values to a Customer class and using underscore notation (\"_\"), \r\nSlapper.AutoMapper properly populates the nested child types. This is really what I would consider this libraries secret sauce.\r\nYou can just as easily use a list of dynamics which is demonstrated below too which is what is typically returned back from Micro ORMs.\r\n\r\nAs an example, the following SQL would return similar results to what is in the dictionaries in the example below ( Note the use of SQL aliases ).\r\n\r\n*Now it may not seem immediately obvious but what we are really achieving here is something very interesting... we are effectively combining\r\nSQL and the mapping to C# objects at the same time by use of SQL aliases.*\r\n\r\n```sql\r\nSELECT\tc.CustomerId,\r\n\t\tc.FirstName,\r\n\t\tc.LastName,\r\n\t\to.OrderId AS Orders_OrderId,\r\n\t\to.OrderTotal AS Orders_OrderTotal,\r\n\t\tod.OrderDetailId AS Orders_OrderDetails_OrderId,\r\n\t\tod.OrderDetailId AS Orders_OrderDetails_OrderDetailId,\r\n\t\tod.OrderDetailTotal AS Orders_OrderDetails_OrderDetailTotal\r\nFROM\tCustomer c\r\n\t\tJOIN Order o ON c.CustomerId = o.CustomerId\r\n\t\tJOIN OrderDetail od ON o.OrderId = od.OrderId\r\n```\r\n\r\nThis example is indicative of the results you would commonly encounter when querying a database and joining on an Orders\r\nand OrderDetails table --you would get back duplicate results in some fields. Notice how the CustomerId in both dictionaries\r\nare the same. Because of Slapper.AutoMapper's default conventions, it will identify the CustomerId field as being the \r\nidentifier ( or primary key so to speak ). This means that when it attempts to convert the second dictionary to a Customer \r\nobject, it will see that it has already created a Customer object with an CustomerId of 1 and will simply re-use the previous \r\ninstance resulting in only one Customer object being returned back. This is how Slapper.AutoMapper effectively groups results\r\ntogether and is the key to this libraries awesomeness.\r\n\r\n\r\n```csharp\r\npublic class Customer\r\n{\r\n\tpublic int CustomerId;\r\n\tpublic string FirstName;\r\n\tpublic string LastName;\r\n\tpublic IList<Order> Orders;\r\n}\r\n\r\npublic class Order\r\n{\r\n\tpublic int OrderId;\r\n\tpublic decimal OrderTotal;\r\n\tpublic IList<OrderDetail> OrderDetails;\r\n}\r\n\r\npublic class OrderDetail\r\n{\r\n\tpublic int OrderDetailId;\r\n\tpublic decimal OrderDetailTotal;\r\n}\r\n\t\t\r\n[Test]\r\npublic void I_Can_Map_Nested_Types_And_Resolve_Duplicate_Entries_Properly()\r\n{\r\n\t// Arrange\r\n\tvar dictionary = new Dictionary<string, object>\r\n\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t { \"CustomerId\", 1 },\r\n\t\t\t\t\t\t\t { \"FirstName\", \"Bob\" },\r\n\t\t\t\t\t\t\t { \"LastName\", \"Smith\" },\r\n\t\t\t\t\t\t\t { \"Orders_OrderId\", 1 },\r\n\t\t\t\t\t\t\t { \"Orders_OrderTotal\", 50.50m },\r\n\t\t\t\t\t\t\t { \"Orders_OrderDetails_OrderDetailId\", 1 },\r\n\t\t\t\t\t\t\t { \"Orders_OrderDetails_OrderDetailTotal\", 25.00m }\r\n\t\t\t\t\t\t };\r\n\r\n\tvar dictionary2 = new Dictionary<string, object>\r\n\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t { \"CustomerId\", 1 },\r\n\t\t\t\t\t\t\t { \"FirstName\", \"Bob\" },\r\n\t\t\t\t\t\t\t { \"LastName\", \"Smith\" },\r\n\t\t\t\t\t\t\t { \"Orders_OrderId\", 1 },\r\n\t\t\t\t\t\t\t { \"Orders_OrderTotal\", 50.50m },\r\n\t\t\t\t\t\t\t { \"Orders_OrderDetails_OrderDetailId\", 2 },\r\n\t\t\t\t\t\t\t { \"Orders_OrderDetails_OrderDetailTotal\", 25.50m }\r\n\t\t\t\t\t\t };\r\n\r\n\tvar list = new List<IDictionary<string, object>> { dictionary, dictionary2 };\r\n\r\n\t// Act\r\n\tvar customers = Slapper.AutoMapper.Map<Customer>( list );\r\n\r\n\t// Assert\r\n\t\r\n\t// There should only be a single customer\r\n\tAssert.That( customers.Count() == 1 );\r\n\r\n\t// There should only be a single Order\r\n\tAssert.That( customers.FirstOrDefault().Orders.Count == 1 );\r\n\r\n\t// There should be two OrderDetails\r\n\tAssert.That( customers.FirstOrDefault().Orders.FirstOrDefault().OrderDetails.Count == 2 );\r\n}\r\n\r\n[Test]\r\npublic void I_Can_Map_Nested_Types_And_Resolve_Duplicate_Entries_Properly_Using_Dynamics()\r\n{\r\n    // Arrange\r\n    dynamic customer1 = new ExpandoObject();\r\n    customer1.CustomerId = 1;\r\n    customer1.FirstName = \"Bob\";\r\n    customer1.LastName = \"Smith\";\r\n    customer1.Orders_OrderId = 1;\r\n    customer1.Orders_OrderTotal = 50.50m;\r\n    customer1.Orders_OrderDetails_OrderDetailId = 1;\r\n    customer1.Orders_OrderDetails_OrderDetailTotal = 25.00m;\r\n\r\n    dynamic customer2 = new ExpandoObject();\r\n    customer2.CustomerId = 1;\r\n    customer2.FirstName = \"Bob\";\r\n    customer2.LastName = \"Smith\";\r\n    customer2.Orders_OrderId = 1;\r\n    customer2.Orders_OrderTotal = 50.50m;\r\n    customer2.Orders_OrderDetails_OrderDetailId = 2;\r\n    customer2.Orders_OrderDetails_OrderDetailTotal = 25.50m;\r\n\r\n    var customerList = new List<dynamic> { customer1, customer2 };\r\n\r\n    // Act\r\n    var customers = Slapper.AutoMapper.MapDynamic<Customer>( customerList );\r\n\r\n    // Assert\r\n\r\n    // There should only be a single customer\r\n    Assert.That( customers.Count() == 1 );\r\n\r\n    // There should only be a single Order\r\n    Assert.That( customers.FirstOrDefault().Orders.Count == 1 );\r\n\r\n    // There should be two OrderDetails\r\n    Assert.That( customers.FirstOrDefault().Orders.FirstOrDefault().OrderDetails.Count == 2 );\r\n}\r\n```\r\n\r\nUsage - Auto Mapping and Identifiers\r\n====================================\r\n\r\n###Auto Mapping###\r\n\r\nAuto mapping allows Slapper to figure out how to effectively group objects together so that you do not get \r\nduplicate results. Now internally, no actual grouping is happening but this is the easiest way to conceptualize\r\nhow it works.\r\n\r\n*For the curious, the actual implementation relies upon an instance cache implemented as a Dictionary where the key is the all of\r\nthe identifier's hashes summed together and the value being the instance.*\r\n\r\nA classes identifier(s) play an important role in the ability of the mapper to effectively group objects together. If no\r\nidentifiers are found, the mapper will still map the results to the requested type but there will be duplicates in the results.\r\n\r\n\r\n####Default Convention####\r\nSlapper.AutoMapper uses three different conventions in an attempt to locate/match a requested types\r\nidentifier:\r\n- Id\r\n- TypeName + Id\r\n- TypeName + Nbr\r\n\r\nFor example, if your Customer object has any of the following properties or fields, it will use it as the identifier:\r\n- Id\r\n- CustomerId\r\n- CustomerNbr\r\n\r\n####Creating Your Own Convention####\r\n\r\nYou can specify your own conventions very easily. The following example creates a convention of TypeName + _Id:\r\n\r\n```csharp\r\nSlapper.AutoMapper.Configuration.IdentifierConventions.Add( type => type.Name + \"_Id\" );\r\n````\r\n\r\n####Manually Specifying the Identifier(s)####\r\n\r\nSlapper allows you to manually specify a classes identifiers. 1 through N number of identifiers are supported.\r\n\r\nThe following example specifies two identifiers for the Customer object by using the AddIdentifiers() method:\r\n\r\n\r\n```csharp\r\npublic class Customer\r\n{\r\n\tpublic int CustomerId;\r\n\r\n\tpublic string CustomerType;\r\n\r\n\tpublic string FirstName;\r\n\r\n\tpublic string LastName;\r\n}\r\n\r\nSlapper.AutoMapper.Configuration.AddIdentifiers( typeof( Customer ), new List<string> { \"CustomerId\", \"CustomerType\" } );\r\n````\r\n\r\n####Attribute-based Identifiers####\r\n\r\nSlapper.AutoMapper also supports attribute-based identifiers.\r\n\r\nBy default, the library uses it's own Id attribute that allows you to simply decorate the identifiers on your class with\r\na `[Slapper.AutoMapper.Id]` attribute.\r\n\r\nIf you wish to use your own attribute instead of the default one, just set the Type to use on the following field:\r\n\r\n```csharp\r\nSlapper.AutoMapper.Configuration.IdentifierAttributeType = typeof( YourCustomAttribute );\r\n``` \r\n\r\nThe following example specifies two identifiers for the Customer object:\r\n\r\n```csharp\r\npublic class Customer\r\n{\r\n\t[Slapper.AutoMapper.Id]\r\n\tpublic int CustomerId;\r\n\r\n\t[Slapper.AutoMapper.Id]\r\n\tpublic string CustomerType;\r\n\r\n\tpublic string FirstName;\r\n\r\n\tpublic string LastName;\r\n}\r\n````\r\n\r\nUsage - Caching\r\n===============\r\n\r\n####Caching Explained####\r\n\r\nSlapper.AutoMapper internally maintains a cache of every object it creates, referred to as the instance cache.\r\nThis cache plays an important role in Slapper's ability to easily lookup existing objects and ultimately assists\r\nin the ability for Slapper.AutoMapper to populate complex nested types.\r\n\r\nSlapper.AutoMapper itself never removes an instance from this cache, so if you tell it to create 50,000 objects, \r\nthen there are going to be 50,000 objects in the cache for the lifetime of the current thread or Http context. \r\n\r\nThe instance cache exists for the lifetime of the current thread and each of your application's threads will\r\nget it's own unique cache making use of this library thread safe.\r\n\r\n####Cache Backing Store####\r\n\r\nThe instance cache backing store will either make use of the HttpContext if one exists or the CallContext of the\r\nexecuting thread. The library makes use of reflection in order to persist the cache in the HttpContext when\r\nneccessary so that the library does not require a dependency on the System.Web library.\r\n\r\n####Clearing the Cache###\r\n\r\nSlapper never clears the cache because we feel that it should be the consumer of this library that should have that \r\nresponsibility.\r\n\r\nIf you would like to clear this cache, you can do so at any time like so:\r\n\r\n```csharp\r\nSlapper.AutoMapper.Cache.ClearInstanceCache();\r\n````\r\n\r\n\r\n###License###\r\n\r\nMIT License:\r\n\r\nCopyright (c) 2016, Randy Burden and contributors.\r\nAll rights reserved.\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and \r\nassociated documentation files (the \"Software\"), to deal in the Software without restriction, including \r\nwithout limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \r\ncopies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the \r\nfollowing conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial \r\nportions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT \r\nLIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN \r\nNO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, \r\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE \r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \r\n\r\nDescription:\r\n\r\nSlapper.AutoMapper maps dynamic data to static types. Slap your data into submission!\r\n\r\nSlapper.AutoMapper ( Pronounced Slapper-Dot-Automapper ) is a mapping library that can convert \r\ndynamic data into static types and populate complex nested child objects.\r\nIt primarily converts C# dynamics and IDictionary<string, object> to strongly typed objects and supports\r\npopulating an entire object graph by using underscore notation to underscore into nested objects.\r\n","google":"UA-36766254-1","note":"Don't delete this file! It's used internally to help with page regeneration."}